## CSRF에 대해 설명해주세요.

CSRF(Cross-Site Request Forgery)는 웹 애플리케이션의 주요 보안 취약점 중 하나입니다.
공격자가 사용자의 의지와는 무관하게 사용자가 현재 인증된 웹 사이트에서 특정 요청을 강제로 보내도록 만든 공격 기법입니다.

웹 사이트 사용자는 로그인 이후 해당 웹 사이트의 API나 기능을 사용할 수 있는 인증 상태를 갖게 됩니다.
CSRF공격은 바로 이 인증된 사용자의 권한을 도용항 공격자가 원하는 행동을 피해자의 브라우저를 통해 마치 피해자가 직접 요청한 것처럼 실행시키는 방식입니다.

### CSRF 작동 방식
1. 피해자는 취약한 웹 사이트 A에 로그인하여 인증된 세션(쿠키)을 가지고 있습니다.
2. 공격자는 웹 사이트 A에 특정 작업을 수행시키는 악의적인 요청(비밀번호 변경이나 게시글 삭제, 상품 구매 등)을 만듭니다.
3. 공격자는 이 악의적인 요청을 피해자가 실행하도록 유도합니다. 
-> 피해자가 이메일의 링크를 클릭하도록 유도하거나 공격자가 제어하는 웹 사이트 B에 악성 스크립트를 숨겨 놓고 피해자가 웹 사이트 B를 방문하도록 유도
4. 피해자의 브라우저는 웹 사이트 B에 숨겨진 악의적인 요청을 웹사이트 A로 전송합니다.
5. 웹 사이트 A의 서버는 해당 요청이 정상적인 사용자의 인증된 요청이라고 판단하고 공격자가 의도한 작업을 수행합니다.

#### CSRF 예시
* **비밀번호 변경** : 피해자가 로그인된 상태에서 공격자가 만든 악성 링크를 클릭하면 자신도 모르게 비밀번호가 변경될 수 있습니다.
악성 요청 예시 : `https://target-website.com/change-password?new_password=sample`
* **게시글 작성/삭제** : 특정 게시판에 피해자의 이름으로 악의적인 글이 작성되거나, 중요한 글이 삭제될 수 있습니다.
* **장바구니 조작** : 피해자의 장바구니에 원치 않는 상품을 추가하거나 삭제할 수 있습니다.
* **금융 거래** : 보안이 허술한 경우 피해자의 계좌에서 자금을 이체하는 요청을 보낼 수도 있습니다.

### CSRF 방어 방법
**요청이 정말로 사용자의 의도에 의해 발생한 것인지 서버가 검증**하는 것이 중요합니다.

#### 1. Synchronizer Token Pattern (Anti-CSRF 토큰)
가장 강력한 방법으로 사용자가 웹 사이트에 접속하면 서버는 각 사용자 세션에 대해 고유하고 예측 불가능한 토큰을 생성합니다.
서버는 이 토큰을 사용자의 세션에 저장하고 동시에 HTML 폼의 숨겨진 필드나 커스텀 HTTP 헤더를 통해 클라이언트에 전달합니다.
사용자가 상태를 변경하는 요청을 보낼 때 브라우저는 이 Anti-CSRF 토큰을 요청에 포함시키 서버로 전송합니다.
서버는 수신된 요청에 포함된 토큰과 세션에 저장된 토큰을 비교합니다.
두 토큰이 일치하면 요청을 정상적으로 처리하고 일치하지 않으면 CSRF 공격으로 간주하여 요청을 거부합니다.

이 방법은 공격자는 사용자의 세션 토큰을 알 수 없으므로, 유효한 Anti-CSRF 토큰을 요청에 포함시킬 수 없어 공격이 차단됩니다.

#### 2. SameSite Cookie Attribute 
쿠키의 `SameSite` 속성으로 해당 쿠키가 다른 도메인에서의 요청에 포함되어 전송될지 여부를 제어합니다.
* `Strict` : 가장 엄격한 설정으로 모든 종류의 Cross-Site 요청에서 쿠키 전송을 차단합니다.
* `Lax` : 일부 Cross-Site 요청에서 쿠키를 허용하지만 `POST` `PUT` `DELETE`등의 Cross-Site 요청에서는 쿠키 전송을 차단합니다.
최신 브라우저에서 점차 기본값으로 설정되는 추세이며 대부분의 CSRF 공격을 효과적으로 방어합니다.
* `None` : 모든 Cross-Site 요청에 쿠키 전송을 허용합니다.

브라우저 레벨에서 CSRF를 상당 부분 방어할 수 있고 구현이 비교적 간단합니다.
하지만 오래된 브라우저에서는 지원하지 않을 수 있으며 `Lax`설정도 모든 CSRF를 완벽히 막지는 못할 수 있습니다.

#### 3. Referer 헤더 및 Origin 헤더 검증
서버에서 HTTP 요청 헤더의 `Referer`또는 `Origin`을 확인하여 허용된 도메인에서 온 요청인지 검증합니다.

비교적 간단하게 구현이 가능하나 `Referer`헤더는 사용자의 개인 정보 보호 설정이나 프록시 등에 의해 생략되거나 조작될 수 있습니다.
완벽한 방어책이라기보다 보조적인 수단으로 사용됩니다.

#### 4. 중요 작업에 대한 재인증
비밀번호 변경, 금융 거래, 계정 탈퇴 등 매우 중요한 작업을 수행하기 전 사용자에게 빔리번호를 다시 입력하도록 요구하여 해당 작업이 정말 사용자의 의도인지 한 번 더 확인합니다.

#### 5. CAPTCHA
중요한 작업 요청 시 CAPTCHA를 통해 사람인지 기계인지 구분하여 자동화된 CSRF 공격을 방지할 수 있습니다.
