## 이터러블 프로토콜에 대해 설명해주세요.

이터러블 프로토콜(Iterable Protocol)은 JavaScript에서 데이터 컬렉션이나 시퀸스를 순차적으로 순회하여 탐색할 수 있도록 정해 놓은 프로토콜입니다.
이 프로토콜은 다양한 자료구조를 동일한 방식으로 순회할 수 있게 하여 개발자에게 일관되고 편리한 반복 처리 방법을 제공합니다.

예를 들어, `Array` `String` `Map` `Set`등은 내부 구조와 데이터를 저장하는 방식이 다릅니다.
하지만 이들 모두 이터러블 프로토콜을 따르고 있기에 `for ...of` 반복문이나 스프레드 연산자(...), 구조 분해 할당 등 동일한 문법으로 동일하게 순회할 수 있습니다.
이런 통일성 덕분에 개발자는 어떤 자료구조에 상관없이 동일한 방식으로 데이터를 다룰 수 있습니다.

#### 이터러블이 되기 위한 조건
이터러블 프로토콜을 따른다고 말하려면 해당 객체에 `Symbol.iterator`라는 키를 가진 메서드가 정의되어 있어야 하며 이 메서드는 이터레이터 객체를 반환해야 합니다.
```
const anIterableObject = {
  // 이 객체는 Symbol.iterator 메서드를 가지고 있으므로 이터러블합니다.
  [Symbol.iterator]: function() {
    // 이 메서드는 이터레이터 객체를 반환해야 합니다.
    return /* 이터레이터 객체 */;
  }
};
```

### 이터레이터 프로토콜(Iterator Protocol)
이터레이터 객체는 반드시 `next()`라는 메서드를 가져야 합니다.
이 `next()`메서드를 호출할 때마다 이터레이터는 순회 중인 데이터 컬렉션의 다음 요소를 반환합니다.
반환하는 객체는 `value, done`두 가지 속성을 가집니다.
* `value` : 현재 순회 단계의 데이터 값입니다. 순회가 끝났다면 `undefined`가 될 수 있습니다.
* `done` : 순회가 종료되었는지를 나타내는 불리언 값입니다.

이 `next()`메서드를 반복적으로 호출함으로서 이터러블 객체 내부의 데이터를 순서대로 하나씩 꺼내올 수 있습니다.
```
// 이터레이터 객체의 예시
const anIterator = {
  next: function() {
    if (/* 아직 순회할 요소가 있다면 */) {
      return { value: /* 다음 요소 값 */, done: false };
    } else {
      return { value: undefined, done: true }; // 순회 종료
    }
  }
};
```

### 이터러블 프로토콜 장점
* **일관성** : 다양한 타입의 데이터 소스를 동일한 방식으로 순회할 수 있어 코드의 일관성과 가독성이 향상됩니다.
* **재사용성** : `for ...of` 스프레드 문법 등 재사용 가능한 코드를 작성하기 용이합니다.
* **상호 운용성** : JavaScript 언어의 많은 내장 기능들이 이터러블을 기반으로 동작하므로 직접 만든 객체도 이러한 기능들과 쉽게 통합될 수 있습니다.
* **지연 평가** : 필요한 시점에만 데이터를 계산하여 제공하는 지연 평가 방식의 이터레이터를 구현할 수 있어 무한한 시퀸스나 대용량 데이터를 효율적으로 다룰 수 있습니다.
